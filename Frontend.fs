/// The Starling-language frontend driver.
module Starling.Lang.Frontend

open Chessie.ErrorHandling
open Starling
open Starling.Model
open Starling.Pretty.Misc
open Starling.Lang.Modeller
open Starling.Lang.Parser
open Starling.Lang.Destructurer
open Starling.Lang.Guarder

(*
 * Request and response types
 *)

/// Type of requests to the Starling frontend.
type Request = 
    /// Only parse a Starling script; return `Response.Parse`.
    | Parse
    /// Parse and collate a Starling script; return `Response.Collate`.
    | Collate
    /// Parse, collate, and model a Starling script; return `Response.Model`.
    | Model
    /// Parse, collate, model, and guard a Starling script;
    /// return `Response.Guard`.
    | Guard
    /// Parse, collate, model, guard, and destructure a Starling script;
    /// return `Response.Destructure`.
    | Destructure

/// Type of responses from the Starling frontend.
type Response =
    /// Output of the parsing step only. 
    | Parse of AST.ScriptItem list
    /// Output of the parsing and collation steps.
    | Collate of Collator.CollatedScript
    /// Output of the parsing, collation, and modelling steps.
    | Model of Model<Axiom<CView, PartCmd<CView>>, DView>
    /// Output of the parsing, collation, modelling, and guarding stages.
    | Guard of Model<Axiom<GView, PartCmd<GView>>, DView>
    /// Output of the parsing, collation, modelling, guarding and destructuring stages.
    | Destructure of Model<PAxiom<GView>, DView>

(*
 * Error types
 *)

/// Type of errors generated by the Starling frontend.
type Error = 
    /// A parse error occurred, details of which are enclosed in string form.
    | Parse of string
    /// A modeller error occurred, given as a `ModelError`.
    | Model of Errors.Lang.Modeller.ModelError

(*
 * Pretty-printing
 *)

/// Pretty-prints a response.
let printResponse showModel =
    (* See Main.fs for what this is doing.
     * TODO(CaptainHayashi): work out a way to de-duplicate this while still
     * appeasing F#'s type system.
     *)
    let pmodel pA pD m =
        if showModel
        then printModel pA pD m
        else printNumHeaderedList pA m.Axioms
    
    function 
    | Response.Parse s -> Pretty.Lang.AST.printScript s
    | Response.Collate c -> printCollatedScript c
    | Response.Model m -> pmodel (printAxiom (printPartCmd printCView) printCView) printDView m
    | Response.Guard m -> pmodel (printAxiom (printPartCmd printGView) printGView) printDView m
    | Response.Destructure m -> pmodel (printPAxiom printGView) printDView m

/// Pretty-prints an error.
let printError =
    function
    | Error.Parse e -> Pretty.Types.String e
    | Error.Model e -> Pretty.Errors.printModelError e

(*
 * Driver functions
 *)

/// Shorthand for the parser stage of the frontend pipeline.
let parse = Parser.parseFile >> mapMessages Error.Parse
/// Shorthand for the collation stage of the frontend pipeline.
let collate = lift Collator.collate
/// Shorthand for the modelling stage of the frontend pipeline.
let model = bind (Modeller.model >> mapMessages Error.Model)
/// Shorthand for the guard stage.
let guard = lift Guarder.guard
/// Shorthand for the destructure stage.
let destructure = lift Destructurer.destructure

/// Runs the Starling frontend.
/// Takes two arguments: the first is the `Response` telling the frontend what
/// to output; the second is an optional filename from which the frontend
/// should read (if empty, read from stdin).
let run =
    function
    | Request.Parse -> parse >> lift Response.Parse
    | Request.Collate -> parse >> collate >> lift Response.Collate
    | Request.Model -> parse >> collate >> model >> lift Response.Model
    | Request.Guard -> parse >> collate >> model >> guard >> lift Response.Guard
    | Request.Destructure -> parse >> collate >> model >> guard >> destructure >> lift Response.Destructure
