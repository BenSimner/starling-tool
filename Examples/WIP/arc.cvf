/* Atomic reference counter
 * Example taken from Derek: http://www.mpi-sws.org/~dreyer/talks/talk-dagstuhl16.pdf
 */ 

/* Currently (c. May 2016) this doesn't work: we probably need iterated views */ 

shared bool free; 
shared int cnt; 

thread bool f; 
thread int c; 

thread bool dummy; // used in dummy skips 

method clone() { 
  {| arc() |} 
    < cnt++ >;
  {| arc() * arc() |}  
} 

method print() {
  {| arc() |}  
    <f = free>; 
  {| arc() * freeVal(f) |} 
    // Test for disposal
    if (f == true) { 
      {| error() |} 
        dummy = dummy; // skip; 
      {| error() |} 
    } else { 
      {| arc() |}  
        dummy = dummy; // skip; 
      {| arc() |}  
    }  
  {| arc() |} 
} 

method drop() { 
  {| arc() |} 
    < c = cnt-- >; 
  {| cntVal(c) |} 
    if (c == 0) { 
      {| noArc() |} 
        <free = (true)>; 
      {| emp |} 
    } else { 
      {| emp |} 
        dummy = dummy; // skip; 
      {| emp |} 
    } 
  {| emp |} 
} 

view error(); 
view arc(); 
view noArc(); 
view freeVal(bool f); 
view cntVal(int c); 

constraint error()            ->  false; 
constraint arc()              ->  cnt > 0 && free == false; 
constraint noArc()            ->  cnt == 0 && free == false; 
constraint noArc() * arc()    ->  false; 
constraint freeVal(f)         ->  free == f; 
constraint arc() * cntVal(c)  ->  c > 0; 

